var searchIndex = {};
searchIndex["allocators"] = {"doc":"This tiny crate defines a simple allocator interface.","items":[[3,"DefaultHeap","allocators","An implementation of `Allocator` that allocates using the default heap allocator",null,null],[8,"Allocator","","A trait for all allocators that collections can be generic about",null,null],[10,"allocate","","Allocate enough memory to store `capacity` of `T`",0,null],[10,"deallocate","","Free previously allocated memory from pointer.",0,null],[11,"allocate","","",1,null],[11,"deallocate","","",1,null]],"paths":[[8,"Allocator"],[3,"DefaultHeap"]]};
searchIndex["chunked"] = {"doc":"This crate offers an abstraction over allocating fixed-size chunks of memory and different low-level collection types making use of these chunks to emulate \"infinite\" dynamically growing storage.","items":[[3,"MemChunker","chunked","Implementation of `Chunker` for temporary heap memory",null,null],[3,"ValueInChunk","","A simple value, stored in a chunk. Typically used to store metadata of collections (such as length) using the same kind of (non-)persistence as the items of the collection",null,null],[3,"SizedChunkedArena","","A simple array-like collection of fixed-size items of unknown type",null,null],[12,"chunker","","Chunker which is used to create and destroy chunks as needed",0,null],[12,"chunks","","List of allocated chunks",0,null],[12,"item_size","","Item size in bytes",0,null],[3,"ChunkedVec","","A vector which stores items of a known type in a `SizedChunkedArena`",null,null],[3,"ChunkedQueue","","A FIFO queue which stores heterogeneously sized items",null,null],[3,"MultiSized","","Based on a collection type for fixed-size items (\"Bin\"), creates a collection for heterogenously-sized items which will be stored in the most appropriately-sized bin.",null,null],[12,"bins","","All fixed-size bins in this multi-sized collection",1,null],[8,"Chunker","","Describes a strategy for creation and destruction of chunks, adhering to configurable settings",null,null],[10,"chunk_size","","Get the set chunk size",2,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[10,"name","","Get the set chunk name root",2,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[10,"with_chunk_size","","Create an identical chunker, but with different chunk size",2,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"box"}}],[10,"with_name","","Create an identical chunker, but with a different name",2,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"box"}}],[10,"child","","Create an identical chunker, with the name of the current chunker extended by a suffix.",2,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"box"}}],[10,"create_chunk","","Create a new chunk with the set chunk size",2,null],[11,"load_chunk","","Load a persisted chunk that was previously created by this chunker, given an index to identify the particular chunk. Note: the default implementation just creates a new, empty chunk",2,null],[10,"destroy_chunk","","Destroys a chunk that was created by this chunker as well as any persisted representation of the chunk.",2,null],[8,"SizedChunkedCollection","","Any kind of dynamically-growing collection of fixed-size items that uses chunks",null,null],[10,"new","","Create a new collection based on a chunker and item size",3,{"inputs":[{"name":"box"},{"name":"usize"}],"output":{"name":"self"}}],[11,"clone","","",4,{"inputs":[{"name":"self"}],"output":{"name":"memchunker"}}],[11,"from_settings","","Create a new `MemChunker` with the given settings",4,{"inputs":[{"name":"str"},{"name":"usize"}],"output":{"name":"box"}}],[11,"chunk_size","","",4,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"name","","",4,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"with_chunk_size","","",4,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"box"}}],[11,"with_name","","",4,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"box"}}],[11,"child","","",4,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"box"}}],[11,"create_chunk","","",4,null],[11,"destroy_chunk","","",4,null],[11,"new","","Create a new value with a given default. The default is used if no persisted chunk for this value was found.",5,{"inputs":[{"name":"box"},{"name":"t"}],"output":{"name":"valueinchunk"}}],[11,"deref","","",5,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[11,"deref_mut","","",5,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[11,"drop","","",5,{"inputs":[{"name":"self"}],"output":null}],[11,"len","","Number of elements in the collection",0,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"is_empty","","Is the collection empty?",0,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"push","","Allocate space for a new item, returns a pointer to where the new item can be written to and the index that the new item will have.",0,null],[11,"pop_away","","Remove the last item from the end",0,{"inputs":[{"name":"self"}],"output":null}],[11,"swap_remove","","Remove the item at index, by swapping it with the last item and then popping, returning the removed item, if it existed.",0,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"option"}}],[11,"at","","Get a pointer to the item at `index`",0,null],[11,"at_mut","","Get a mutable pointer to the item at `index`",0,null],[11,"new","","",0,{"inputs":[{"name":"box"},{"name":"usize"}],"output":{"name":"self"}}],[11,"new","","Create a new chunked vector",6,{"inputs":[{"name":"box"}],"output":{"name":"self"}}],[11,"len","","Get the number of elements in the vector",6,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"is_empty","","Is the chunked vector empty?",6,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"at","","Get a reference to the item at `index`",6,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"item"}}],[11,"at_mut","","Get a mutable reference to the item at `index`",6,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"item"}}],[11,"push","","Push an item onto the vector",6,{"inputs":[{"name":"self"},{"name":"item"}],"output":null}],[11,"pop","","Remove and return the last item, if the vector wasn't empty",6,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"new","","Create a new chunked queue based on a chunker",7,{"inputs":[{"name":"box"}],"output":{"name":"self"}}],[11,"len","","Number of items in the queue",7,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"is_empty","","Is the queue empty?",7,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"enqueue","","Enqueue an item of a given size. Returns a pointer that the item can be written to.",7,null],[11,"dequeue","","Dequeue an item. Returns a pointer to the item in the queue, unless the queue is empty.",7,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"drop_old_chunks","","Delete chunks which have already been read",7,{"inputs":[{"name":"self"}],"output":null}],[11,"new","","Create a new `MultiSized` collection using the given chunker as a main chunker and a base size that represents the smallest expected item size (this will be used as the item size of the smallest-sized Bin)",1,{"inputs":[{"name":"box"},{"name":"usize"}],"output":{"name":"self"}}],[11,"size_to_index","","Get the index of the Bin which stores items of size `size`",1,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"usize"}}],[11,"bin_for_size_mut","","Get a reference to the Bin most appropriately sized given item size `size`",1,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"b"}}]],"paths":[[3,"SizedChunkedArena"],[3,"MultiSized"],[8,"Chunker"],[8,"SizedChunkedCollection"],[3,"MemChunker"],[3,"ValueInChunk"],[3,"ChunkedVec"],[3,"ChunkedQueue"]]};
searchIndex["compact"] = {"doc":"This crate makes it possible to store objects containing dynamic fields either compactly in consecutive memory or using traditional heap pointers.","items":[[3,"COption","compact","A wrapper to make an `Option` of a nontrivial `Compact` possible. Unfortunately, we can't blanket-`impl` that, since that overlaps (for the compiler) with the `impl` for trivial `Copy` types...",null,null],[12,"0","","",0,null],[3,"CVec","","A dynamically-sized vector that can be stored in compact sequential storage and automatically spills over into free heap storage using `Allocator`. Tries to closely follow the API of `std::vec::Vec`, but is not complete.",null,null],[3,"CDict","","A simple linear-search key-value dictionary, implemented using two `CompactVec`'s, one for keys, one for values.",null,null],[3,"CHashMap","","A dynamically-sized open adressing quadratic probing hashmap that can be stored in compact sequential storage and automatically spills over into free heap storage using `Allocator`.",null,null],[11,"clone","","",0,{"inputs":[{"name":"self"}],"output":{"name":"compactoption"}}],[11,"deref","","",0,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"deref_mut","","",0,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"is_still_compact","","",0,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"dynamic_size_bytes","","",0,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"compact","","",0,null],[11,"decompact","","",0,null],[11,"len","","Get the number of elements in the vector",1,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"is_empty","","Is the vector empty?",1,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"new","","Create a new, empty vector",1,{"inputs":[],"output":{"name":"compactvec"}}],[11,"with_capacity","","Create a new, empty vector with a given capacity",1,{"inputs":[{"name":"usize"}],"output":{"name":"compactvec"}}],[11,"capacity","","current capacity",1,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"push","","Push an item onto the vector, spills onto the heap if the capacity in compact storage is insufficient",1,{"inputs":[{"name":"self"},{"name":"t"}],"output":null}],[11,"push_at","","push at position",1,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"t"}],"output":null}],[11,"extend_from_copy_slice","","Extend from a copyable slice",1,null],[11,"pop","","Pop and return the last element, if the vector wasn't empty",1,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"insert","","Insert a value at `index`, copying the elements after `index` upwards",1,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"t"}],"output":null}],[11,"remove","","Remove the element at `index`, copying the elements after `index` downwards",1,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"t"}}],[11,"retain","","Take a function which returns whether an element should be kept, and mutably removes all elements from the vector which are not kept",1,{"inputs":[{"name":"self"},{"name":"f"}],"output":null}],[11,"truncate","","Truncate the vector to the given length",1,{"inputs":[{"name":"self"},{"name":"usize"}],"output":null}],[11,"clear","","Clear the vector",1,{"inputs":[{"name":"self"}],"output":null}],[11,"drain","","Drain (empty & iterate over) the vector",1,{"inputs":[{"name":"self"}],"output":{"name":"intoiter"}}],[11,"ptr_to_string","","debug printing",1,{"inputs":[{"name":"self"}],"output":{"name":"string"}}],[11,"from","","Create a `CompactVec` from a normal `Vec`, directly using the backing storage as free heap storage",1,{"inputs":[{"name":"vec"}],"output":{"name":"self"}}],[11,"drop","","Drop elements and deallocate free heap storage, if any is allocated",1,{"inputs":[{"name":"self"}],"output":null}],[11,"deref","","",1,null],[11,"deref_mut","","",1,null],[11,"into_iter","","",1,null],[11,"is_still_compact","","",1,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"dynamic_size_bytes","","",1,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"compact","","",1,null],[11,"decompact","","",1,null],[11,"is_still_compact","","",1,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"dynamic_size_bytes","","",1,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"compact","","",1,null],[11,"clone","","",1,{"inputs":[{"name":"self"}],"output":{"name":"compactvec"}}],[11,"clone","","",1,{"inputs":[{"name":"self"}],"output":{"name":"compactvec"}}],[11,"from_iter","","",1,{"inputs":[{"name":"i"}],"output":{"name":"self"}}],[11,"extend","","",1,{"inputs":[{"name":"self"},{"name":"i"}],"output":null}],[11,"default","","",1,{"inputs":[],"output":{"name":"compactvec"}}],[11,"fmt","","",1,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Create new, empty dictionary",2,{"inputs":[],"output":{"name":"self"}}],[11,"len","","Amount of entries in the dictionary",2,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"is_empty","","Is the dictionary empty?",2,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"get","","Look up the value for key `query`, if it exists",2,{"inputs":[{"name":"self"},{"name":"k"}],"output":{"name":"option"}}],[11,"get_mut","","Look up the value for keu `query` mutably, if it exists",2,{"inputs":[{"name":"self"},{"name":"k"}],"output":{"name":"option"}}],[11,"get_mru","","Lookup up the value for key `query`, if it exists, but also swap the entry to the beginning of the key/value vectors, so a repeated lookup for that item will be faster",2,{"inputs":[{"name":"self"},{"name":"k"}],"output":{"name":"option"}}],[11,"get_mfu","","Lookup up the value for key `query`, if it exists, but also swap the entry one index towards the beginning of the key/value vectors, so frequently repeated lookups for that item will be faster",2,{"inputs":[{"name":"self"},{"name":"k"}],"output":{"name":"option"}}],[11,"contains_key","","Does the dictionary contain a value for `query`?",2,{"inputs":[{"name":"self"},{"name":"k"}],"output":{"name":"bool"}}],[11,"insert","","Insert new value at key `query` and return the previous value at that key, if any existed",2,{"inputs":[{"name":"self"},{"name":"k"},{"name":"v"}],"output":{"name":"option"}}],[11,"remove","","Remove value at key `query` and return it, if it existed",2,{"inputs":[{"name":"self"},{"name":"k"}],"output":{"name":"option"}}],[11,"keys","","Iterator over all keys in the dictionary",2,{"inputs":[{"name":"self"}],"output":{"name":"iter"}}],[11,"values","","Iterator over all values in the dictionary",2,{"inputs":[{"name":"self"}],"output":{"name":"iter"}}],[11,"values_mut","","Iterator over mutable references to all values in the dictionary",2,{"inputs":[{"name":"self"}],"output":{"name":"itermut"}}],[11,"pairs","","Iterator over all key-value pairs in the dictionary",2,null],[11,"push_at","","Push a value onto the `CompactVec` at the key `query`",2,{"inputs":[{"name":"self"},{"name":"k"},{"name":"i"}],"output":null}],[11,"get_iter","","Iterator over the `CompactVec` at the key `query`",2,null],[11,"remove_iter","","Remove the `CompactVec` at the key `query` and iterate over its elements (if it existed)",2,null],[11,"is_still_compact","","",2,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"dynamic_size_bytes","","",2,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"compact","","",2,null],[11,"decompact","","",2,null],[11,"clone","","",2,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[11,"default","","",2,{"inputs":[],"output":{"name":"self"}}],[11,"from_iter","","Construct a compact dictionary from an interator over key-value pairs",2,{"inputs":[{"name":"t"}],"output":{"name":"self"}}],[11,"extend","","Extend a compact dictionary from an iterator over key-value pairs",2,{"inputs":[{"name":"self"},{"name":"t"}],"output":null}],[11,"new","","constructor",3,{"inputs":[],"output":{"name":"self"}}],[11,"with_capacity","","constructor",3,{"inputs":[{"name":"usize"}],"output":{"name":"self"}}],[11,"len","","Amount of entries in the dictionary",3,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"is_empty","","Is the dictionary empty?",3,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"get","","Look up the value for key `query`, if it exists",3,{"inputs":[{"name":"self"},{"name":"k"}],"output":{"name":"option"}}],[11,"get_mut","","get mutable",3,{"inputs":[{"name":"self"},{"name":"k"}],"output":{"name":"option"}}],[11,"contains_key","","Does the dictionary contain a value for `query`?",3,{"inputs":[{"name":"self"},{"name":"k"}],"output":{"name":"bool"}}],[11,"insert","","Insert new value at key `query` and return the previous value at that key, if any existed",3,{"inputs":[{"name":"self"},{"name":"k"},{"name":"v"}],"output":{"name":"option"}}],[11,"remove","","Remove value at key `query` and return it, if it existed",3,{"inputs":[{"name":"self"},{"name":"k"}],"output":{"name":"option"}}],[11,"keys","","Iterator over all keys in the dictionary",3,null],[11,"values","","Iterator over all values in the dictionary",3,null],[11,"values_mut","","Iterator over mutable references to all values in the dictionary",3,null],[11,"pairs","","Iterator over all key-value pairs in the dictionary",3,null],[11,"is_still_compact","","",3,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"dynamic_size_bytes","","",3,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"compact","","",3,null],[11,"decompact","","",3,null],[11,"clone","","",3,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[11,"default","","",3,{"inputs":[],"output":{"name":"self"}}],[11,"from_iter","","Construct a compact dictionary from an interator over key-value pairs",3,{"inputs":[{"name":"t"}],"output":{"name":"self"}}],[11,"push_at","","Push a value onto the `CompactVec` at the key `query`",3,{"inputs":[{"name":"self"},{"name":"k"},{"name":"i"}],"output":null}],[11,"get_iter","","Iterator over the `CompactVec` at the key `query`",3,null],[11,"remove_iter","","Remove the `CompactVec` at the key `query` and iterate over its elements (if it existed)",3,null],[11,"hash","","",1,{"inputs":[{"name":"self"},{"name":"h"}],"output":null}],[8,"Compact","","A trait for objects with a statically-sized part and a potential dynamically-sized part that can be stored both compactly in consecutive memory or freely on the heap",null,null],[10,"is_still_compact","","Is the object's dynamic part stored compactly?",4,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[10,"dynamic_size_bytes","","Size of the dynamic part in bytes",4,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"total_size_bytes","","Total size of the object (static part + dynamic part)",4,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[10,"compact","","Copy the static part of `source` to `dest` and compactly store the dynamic part of `source` as the new dynamic part of `dest` at `new_dynamic_part`. This semantically moves source into dest.",4,null],[11,"behind","","Get a pointer to behind the static part of `self` (commonly used place for the dynamic part)",4,null],[11,"compact_behind","","Like `compact` with `new_dynamic_part` set to `dest.behind()`",4,null],[10,"decompact","","Creates a clone of self with the dynamic part guaranteed to be stored freely.",4,null],[11,"total_size_bytes","","Total size of the object (static part + dynamic part)",4,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"behind","","Get a pointer to behind the static part of `self` (commonly used place for the dynamic part)",4,null],[11,"compact_behind","","Like `compact` with `new_dynamic_part` set to `dest.behind()`",4,null]],"paths":[[3,"COption"],[3,"CVec"],[3,"CDict"],[3,"CHashMap"],[8,"Compact"]]};
searchIndex["compact_macros"] = {"doc":"Automatic `#[derive(Compact)]` macro for structs whose fields are all `Compact`","items":[[5,"derive_compact","compact_macros","",null,{"inputs":[{"name":"tokenstream"}],"output":{"name":"tokenstream"}}]],"paths":[]};
searchIndex["descartes"] = {"doc":"","items":[[8,"Dot","descartes","Traits of objects having a dot product.",null,null],[10,"dot","","Computes the dot (inner) product of two vectors.",0,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"n"}}],[8,"ToHomogeneous","","Traits of objects which can be put in homogeneous coordinates form.",null,null],[10,"to_homogeneous","","Gets the homogeneous coordinates form of this object.",1,{"inputs":[{"name":"self"}],"output":{"name":"u"}}],[8,"Norm","","Traits of objects having an euclidian norm.",null,null],[16,"NormType","","The scalar type for the norm (i.e. the undelying field).",2,null],[11,"norm","","Computes the norm of `self`.",2,null],[10,"norm_squared","","Computes the squared norm of `self`.",2,null],[10,"normalize","","Gets the normalized version of a copy of `v`.",2,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[10,"normalize_mut","","Normalizes `self`.",2,null],[10,"try_normalize","","Gets the normalized version of a copy of `v` or `None` if the vector has a norm smaller or equal to `min_norm`. In particular, `.try_normalize(0.0)` returns `None` if the norm is exactly zero.",2,null],[10,"try_normalize_mut","","Normalized `v` or does nothing if the vector has a norm smaller or equal to `min_norm`.",2,null],[8,"Inverse","","Trait of objects having an inverse. Typically used to implement matrix inverse.",null,null],[10,"inverse","","Returns the inverse of `m`.",3,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[10,"inverse_mut","","In-place version of `inverse`.",3,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[8,"Rotate","","Trait of objects able to rotate other objects.",null,null],[10,"rotate","","Applies a rotation to `v`.",4,{"inputs":[{"name":"self"},{"name":"v"}],"output":{"name":"v"}}],[10,"inverse_rotate","","Applies an inverse rotation to `v`.",4,{"inputs":[{"name":"self"},{"name":"v"}],"output":{"name":"v"}}],[3,"Circle","","",null,null],[12,"center","","",5,null],[12,"radius","","",5,null],[3,"Line","","",null,null],[12,"start","","",6,null],[12,"direction","","",6,null],[3,"Segment","","",null,null],[12,"start","","",7,null],[12,"center_or_direction","","",7,null],[12,"end","","",7,null],[12,"length","","",7,null],[3,"Intersection","","",null,null],[12,"along_a","","",8,null],[12,"along_b","","",8,null],[12,"position","","",8,null],[3,"Band","","",null,null],[12,"path","","",9,null],[12,"width","","",9,null],[3,"BoundingBox","","",null,null],[12,"min","","",10,null],[12,"max","","",10,null],[5,"convex_hull","","",null,null],[5,"angle_to","","",null,{"inputs":[{"name":"v2"},{"name":"v2"}],"output":{"name":"n"}}],[5,"angle_along_to","","",null,{"inputs":[{"name":"v2"},{"name":"v2"},{"name":"v2"}],"output":{"name":"n"}}],[11,"clone","","",5,{"inputs":[{"name":"self"}],"output":{"name":"circle"}}],[11,"fmt","","",5,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"project_with_tolerance","","",5,{"inputs":[{"name":"self"},{"name":"p2"},{"name":"n"}],"output":{"name":"option"}}],[11,"distance_to","","",5,{"inputs":[{"name":"self"},{"name":"p2"}],"output":{"name":"n"}}],[11,"clone","","",6,{"inputs":[{"name":"self"}],"output":{"name":"line"}}],[11,"fmt","","",6,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"project_with_tolerance","","",6,{"inputs":[{"name":"self"},{"name":"p2"},{"name":"n"}],"output":{"name":"option"}}],[11,"distance_to","","",6,{"inputs":[{"name":"self"},{"name":"p2"}],"output":{"name":"n"}}],[11,"clone","","",7,{"inputs":[{"name":"self"}],"output":{"name":"segment"}}],[11,"fmt","","",7,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"line","","",7,{"inputs":[{"name":"p2"},{"name":"p2"}],"output":{"name":"segment"}}],[11,"arc_with_direction","","",7,{"inputs":[{"name":"p2"},{"name":"v2"},{"name":"p2"}],"output":{"name":"segment"}}],[11,"biarc","","",7,{"inputs":[{"name":"p2"},{"name":"v2"},{"name":"p2"},{"name":"v2"}],"output":{"name":"vec"}}],[11,"is_linear","","",7,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"center","","",7,{"inputs":[{"name":"self"}],"output":{"name":"p2"}}],[11,"radius","","",7,{"inputs":[{"name":"self"}],"output":{"name":"n"}}],[11,"length","","",7,{"inputs":[{"name":"self"}],"output":{"name":"n"}}],[11,"along","","",7,{"inputs":[{"name":"self"},{"name":"n"}],"output":{"name":"p2"}}],[11,"direction_along","","",7,{"inputs":[{"name":"self"},{"name":"n"}],"output":{"name":"v2"}}],[11,"start","","",7,{"inputs":[{"name":"self"}],"output":{"name":"p2"}}],[11,"start_direction","","",7,{"inputs":[{"name":"self"}],"output":{"name":"v2"}}],[11,"end","","",7,{"inputs":[{"name":"self"}],"output":{"name":"p2"}}],[11,"end_direction","","",7,{"inputs":[{"name":"self"}],"output":{"name":"v2"}}],[11,"reverse","","",7,{"inputs":[{"name":"self"}],"output":{"name":"segment"}}],[11,"subsection","","",7,{"inputs":[{"name":"self"},{"name":"n"},{"name":"n"}],"output":{"name":"option"}}],[11,"shift_orthogonally","","",7,{"inputs":[{"name":"self"},{"name":"n"}],"output":{"name":"option"}}],[11,"project_with_tolerance","","",7,{"inputs":[{"name":"self"},{"name":"p2"},{"name":"n"}],"output":{"name":"option"}}],[11,"includes","","",7,{"inputs":[{"name":"self"},{"name":"p2"}],"output":{"name":"bool"}}],[11,"distance_to","","",7,{"inputs":[{"name":"self"},{"name":"p2"}],"output":{"name":"n"}}],[11,"bounding_box","","",7,{"inputs":[{"name":"self"}],"output":{"name":"boundingbox"}}],[11,"clone","","",8,{"inputs":[{"name":"self"}],"output":{"name":"intersection"}}],[11,"fmt","","",8,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"contains","","",5,{"inputs":[{"name":"self"},{"name":"p2"}],"output":{"name":"bool"}}],[11,"clone","","",9,{"inputs":[{"name":"self"}],"output":{"name":"band"}}],[11,"new","","",9,{"inputs":[{"name":"p"},{"name":"n"}],"output":{"name":"band"}}],[11,"outline","","",9,{"inputs":[{"name":"self"}],"output":{"name":"p"}}],[11,"outline_distance_to_path_distance","","",9,{"inputs":[{"name":"self"},{"name":"n"}],"output":{"name":"n"}}],[11,"contains","","",9,{"inputs":[{"name":"self"},{"name":"p2"}],"output":{"name":"bool"}}],[6,"N","","",null,null],[6,"V2","","",null,null],[6,"P2","","",null,null],[6,"V3","","",null,null],[6,"V4","","",null,null],[6,"P3","","",null,null],[6,"M4","","",null,null],[6,"Iso3","","",null,null],[6,"Persp3","","",null,null],[17,"MIN_START_TO_END","","",null,null],[8,"Path","","",null,null],[10,"segments","","",11,null],[10,"new","","",11,{"inputs":[{"name":"vec"}],"output":{"name":"self"}}],[11,"scan_segments","","",11,{"inputs":[{"name":"startoffsetstate"},{"name":"segment"}],"output":{"name":"option"}}],[11,"segments_with_start_offsets","","",11,{"inputs":[{"name":"self"}],"output":{"name":"scan"}}],[11,"find_on_segment","","",11,{"inputs":[{"name":"self"},{"name":"n"}],"output":{"name":"option"}}],[11,"contains","","",11,{"inputs":[{"name":"self"},{"name":"p2"}],"output":{"name":"bool"}}],[11,"self_intersections","","",11,{"inputs":[{"name":"self"}],"output":{"name":"vec"}}],[8,"Intersect","","",null,null],[10,"intersect","","",12,{"inputs":[{"name":"self"}],"output":{"name":"vec"}}],[8,"WithUniqueOrthogonal","","",null,null],[10,"orthogonal","","",13,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[8,"RelativeToBasis","","",null,null],[10,"to_basis","","",14,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"self"}}],[10,"from_basis","","",14,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"self"}}],[8,"Into2d","","",null,null],[16,"Target","","",15,null],[10,"into_2d","","",15,null],[8,"Into3d","","",null,null],[16,"Target","","",16,null],[10,"into_3d","","",16,null],[8,"RoughlyComparable","","",null,null],[11,"is_roughly","","",17,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"bool"}}],[10,"is_roughly_within","","",17,{"inputs":[{"name":"self"},{"name":"self"},{"name":"n"}],"output":{"name":"bool"}}],[8,"Curve","","",null,null],[11,"project_with_max_distance","","",18,{"inputs":[{"name":"self"},{"name":"p2"},{"name":"n"},{"name":"n"}],"output":{"name":"option"}}],[10,"project_with_tolerance","","",18,{"inputs":[{"name":"self"},{"name":"p2"},{"name":"n"}],"output":{"name":"option"}}],[11,"project","","",18,{"inputs":[{"name":"self"},{"name":"p2"}],"output":{"name":"option"}}],[11,"includes","","",18,{"inputs":[{"name":"self"},{"name":"p2"}],"output":{"name":"bool"}}],[10,"distance_to","","",18,{"inputs":[{"name":"self"},{"name":"p2"}],"output":{"name":"n"}}],[8,"FiniteCurve","","",null,null],[10,"length","","",19,{"inputs":[{"name":"self"}],"output":{"name":"n"}}],[10,"along","","",19,{"inputs":[{"name":"self"},{"name":"n"}],"output":{"name":"p2"}}],[10,"direction_along","","",19,{"inputs":[{"name":"self"},{"name":"n"}],"output":{"name":"v2"}}],[10,"start","","",19,{"inputs":[{"name":"self"}],"output":{"name":"p2"}}],[11,"start_direction","","",19,{"inputs":[{"name":"self"}],"output":{"name":"v2"}}],[10,"end","","",19,{"inputs":[{"name":"self"}],"output":{"name":"p2"}}],[11,"end_direction","","",19,{"inputs":[{"name":"self"}],"output":{"name":"v2"}}],[10,"reverse","","",19,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[10,"subsection","","",19,{"inputs":[{"name":"self"},{"name":"n"},{"name":"n"}],"output":{"name":"option"}}],[10,"shift_orthogonally","","",19,{"inputs":[{"name":"self"},{"name":"n"}],"output":{"name":"option"}}],[8,"Shape","","",null,null],[10,"contains","","",20,{"inputs":[{"name":"self"},{"name":"p2"}],"output":{"name":"bool"}}],[8,"HasBoundingBox","","",null,null],[10,"bounding_box","","",21,{"inputs":[{"name":"self"}],"output":{"name":"boundingbox"}}],[11,"orthogonal","","",22,{"inputs":[{"name":"self"}],"output":{"name":"v2"}}],[11,"to_basis","","",22,{"inputs":[{"name":"self"},{"name":"v2"}],"output":{"name":"v2"}}],[11,"from_basis","","",22,{"inputs":[{"name":"self"},{"name":"v2"}],"output":{"name":"v2"}}],[11,"into_2d","","",23,{"inputs":[{"name":"self"}],"output":{"name":"v2"}}],[11,"into_2d","","",24,{"inputs":[{"name":"self"}],"output":{"name":"p2"}}],[11,"into_3d","","",22,{"inputs":[{"name":"self"}],"output":{"name":"v3"}}],[11,"into_3d","","",25,{"inputs":[{"name":"self"}],"output":{"name":"p3"}}],[11,"is_roughly_within","","",26,{"inputs":[{"name":"self"},{"name":"n"},{"name":"n"}],"output":{"name":"bool"}}],[11,"is_roughly_within","","",25,{"inputs":[{"name":"self"},{"name":"p2"},{"name":"n"}],"output":{"name":"bool"}}],[11,"is_roughly_within","","",22,{"inputs":[{"name":"self"},{"name":"v2"},{"name":"n"}],"output":{"name":"bool"}}],[11,"clone","","",10,{"inputs":[{"name":"self"}],"output":{"name":"boundingbox"}}],[11,"infinite","","",10,{"inputs":[],"output":{"name":"self"}}],[11,"overlaps","","",10,{"inputs":[{"name":"self"},{"name":"boundingbox"}],"output":{"name":"bool"}}],[11,"point","","",10,{"inputs":[{"name":"p2"}],"output":{"name":"self"}}],[11,"grown_by","","",10,{"inputs":[{"name":"self"},{"name":"n"}],"output":{"name":"self"}}],[11,"scan_segments","","",11,{"inputs":[{"name":"startoffsetstate"},{"name":"segment"}],"output":{"name":"option"}}],[11,"segments_with_start_offsets","","",11,{"inputs":[{"name":"self"}],"output":{"name":"scan"}}],[11,"find_on_segment","","",11,{"inputs":[{"name":"self"},{"name":"n"}],"output":{"name":"option"}}],[11,"contains","","",11,{"inputs":[{"name":"self"},{"name":"p2"}],"output":{"name":"bool"}}],[11,"self_intersections","","",11,{"inputs":[{"name":"self"}],"output":{"name":"vec"}}]],"paths":[[8,"Dot"],[8,"ToHomogeneous"],[8,"Norm"],[8,"Inverse"],[8,"Rotate"],[3,"Circle"],[3,"Line"],[3,"Segment"],[3,"Intersection"],[3,"Band"],[3,"BoundingBox"],[8,"Path"],[8,"Intersect"],[8,"WithUniqueOrthogonal"],[8,"RelativeToBasis"],[8,"Into2d"],[8,"Into3d"],[8,"RoughlyComparable"],[8,"Curve"],[8,"FiniteCurve"],[8,"Shape"],[8,"HasBoundingBox"],[6,"V2"],[6,"V3"],[6,"P3"],[6,"P2"],[6,"N"]]};
searchIndex["kay"] = {"doc":"`Kay` is a high-performance actor system, suitable for simulating millions of entities.","items":[[3,"Packet","kay","Combination of a message and its destination recipient id",null,null],[12,"recipient_id","","ID of the `Actor`/`Actor` that should receive this message",0,null],[12,"message","","The message itself",0,null],[3,"ID","","An ID that uniquely identifies an `Actor`, or even a `Actor` within a `Swarm`",null,null],[12,"type_id","","An ID for the type of the identified `Actor`, used to dispatch messages to the message handling functions registered for this type",1,null],[12,"machine","","For future use: ID for the machine in a computing cluster or multiplayer environment that the identified `Actor` lives on",1,null],[12,"version","","For future use: allows safe reuse of an ID after `Actor`/`Actor` death. The version is incremented to make the new (otherwise same) ID distinguishable from erroneous references to the `Actor`/`Actor` previously identified",1,null],[12,"instance_id","","Used to identify instances within a top-level `Actor`. The main use-case is `Swarm` identifying and dispatching to its `Instances` using this field",1,null],[3,"ActorSystem","","The main thing inside of which all the magic happens.",null,null],[3,"World","","Gives limited access to an `ActorSystem` (typically from inside, in a message handler) to identify other actors and send messages to them.",null,null],[3,"Networking","","Represents all networking environment and networking state of an `ActorSystem`",null,null],[12,"machine_id","","The machine index of this machine within the network of peers",2,null],[12,"n_turns","","The current network turn this machine is in. Used to keep track if this machine lags behind or runs fast compared to its peers",2,null],[3,"External","","An owning reference to local state outside the actor system that can safely be embedded in actor states and passed in messages, as long as they stay on one machine.",null,null],[4,"Fate","","Return type of message handling functions, signifying if an `Actor`/`Actor` should live on after receiving a certain message type.",null,null],[13,"Live","","Means: the `Actor`/`Actor` should live on",3,null],[13,"Die","","Means: the `Actor`/`Actor` should be stopped, its state can be deallocated",3,null],[11,"is_still_compact","","",0,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"dynamic_size_bytes","","",0,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"compact","","",0,null],[11,"decompact","","",0,null],[11,"clone","","",0,{"inputs":[{"name":"self"}],"output":{"name":"packet"}}],[11,"clone","","",1,{"inputs":[{"name":"self"}],"output":{"name":"id"}}],[11,"eq","","",1,{"inputs":[{"name":"self"},{"name":"id"}],"output":{"name":"bool"}}],[11,"ne","","",1,{"inputs":[{"name":"self"},{"name":"id"}],"output":{"name":"bool"}}],[11,"hash","","",1,null],[11,"new","","Create a new ID",1,{"inputs":[{"name":"shorttypeid"},{"name":"u32"},{"name":"u8"},{"name":"u8"}],"output":{"name":"self"}}],[11,"local_broadcast","","Get a version of an actor ID that signals that a message should be delivered to all machine-local instances.",1,{"inputs":[{"name":"self"}],"output":{"name":"id"}}],[11,"global_broadcast","","Get a version of an actor ID that signals that a message should be delivered globally (to all instances on all machines).",1,{"inputs":[{"name":"self"}],"output":{"name":"id"}}],[11,"is_broadcast","","Check whether this ID signals a local or global broadcast.",1,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_global_broadcast","","Check whether this ID signals specifically a global broadcast.",1,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"fmt","","",1,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Create a new ActorSystem (usually only one per application is needed). Expects to get a panic callback as a parameter that is called when an actor panics during message handling and can thus be used to for example display the panic error message.",4,{"inputs":[{"name":"box"},{"name":"networking"}],"output":{"name":"actorsystem"}}],[11,"register","","Register a new Actor type with the system",4,{"inputs":[{"name":"self"}],"output":null}],[11,"add_handler","","Register a handler for an Actor type and Message type.",4,{"inputs":[{"name":"self"},{"name":"f"},{"name":"bool"}],"output":null}],[11,"add_spawner","","Register a handler that constructs an instance of an Actor type, given an ID",4,{"inputs":[{"name":"self"},{"name":"f"},{"name":"bool"}],"output":null}],[11,"send","","Send a message to the actor(s) with a given `ID`. This is only used to send messages into the system from outside. Inside actor message handlers you always have access to a `World` that allows you to send messages.",4,{"inputs":[{"name":"self"},{"name":"id"},{"name":"m"}],"output":null}],[11,"id","","Get the base ID of an Actor type",4,{"inputs":[{"name":"self"}],"output":{"name":"id"}}],[11,"process_all_messages","","Processes all sent messages, and messages which are in turn sent during the handling of messages, up to a recursion depth of 1000.",4,{"inputs":[{"name":"self"}],"output":null}],[11,"world","","Get a world context directly from the system, typically to send messages from outside",4,{"inputs":[{"name":"self"}],"output":{"name":"world"}}],[11,"networking_connect","","Connect to all peers in the network",4,{"inputs":[{"name":"self"}],"output":null}],[11,"networking_send_and_receive","","Send queued outbound messages and take incoming queued messages and forward them to their local target recipient(s)",4,{"inputs":[{"name":"self"}],"output":null}],[11,"networking_finish_turn","","Finish the current networking turn and wait for peers which lag behind based on their turn number. This is the main backpressure mechanism.",4,{"inputs":[{"name":"self"}],"output":null}],[11,"networking_machine_id","","The machine index of this machine within the network of peers",4,{"inputs":[{"name":"self"}],"output":{"name":"u8"}}],[11,"networking_n_turns","","The current network turn this machine is in. Used to keep track if this machine lags behind or runs fast compared to its peers",4,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"networking_debug_all_n_turns","","Return a debug message containing the current local view of network turn progress of all peers in the network",4,{"inputs":[{"name":"self"}],"output":{"name":"string"}}],[11,"get_instance_counts","","Access to debugging statistics",4,{"inputs":[{"name":"self"}],"output":{"name":"string"}}],[11,"send","","Send a message to a (sub-)actor with the given ID.",5,{"inputs":[{"name":"self"},{"name":"id"},{"name":"m"}],"output":null}],[11,"local_first","","Get the ID of the first machine-local instance of an actor.",5,{"inputs":[{"name":"self"}],"output":{"name":"id"}}],[11,"global_first","","Get the ID of the first instance of an actor on machine 0",5,{"inputs":[{"name":"self"}],"output":{"name":"id"}}],[11,"local_broadcast","","Get the ID for a broadcast to all machine-local instances of an actor.",5,{"inputs":[{"name":"self"}],"output":{"name":"id"}}],[11,"global_broadcast","","Get the ID for a global broadcast to all instances of an actor on all machines.",5,{"inputs":[{"name":"self"}],"output":{"name":"id"}}],[11,"allocate_instance_id","","Synchronously allocate a instance id for a instance that will later manually be added to a Swarm",5,{"inputs":[{"name":"self"}],"output":{"name":"id"}}],[11,"local_machine_id","","Get the id of the machine that we're currently in",5,{"inputs":[{"name":"self"}],"output":{"name":"u8"}}],[11,"new","","Create network environment based on this machines id/index and all peer addresses (including this machine)",2,{"inputs":[{"name":"u8"},{"name":"vec"}],"output":{"name":"networking"}}],[11,"connect","","Connect to all peers in the network",2,{"inputs":[{"name":"self"}],"output":null}],[11,"finish_turn","","Finish the current networking turn and wait for peers which lag behind based on their turn number. This is the main backpressure mechanism.",2,null],[11,"send_and_receive","","Send queued outbound messages and take incoming queued messages and forward them to their local target recipient(s)",2,null],[11,"enqueue","","Enqueue a new (potentially) outbound packet",2,{"inputs":[{"name":"self"},{"name":"shorttypeid"},{"name":"packet"}],"output":null}],[11,"debug_all_n_turns","","Return a debug message containing the current local view of network turn progress of all peers in the network",2,{"inputs":[{"name":"self"}],"output":{"name":"string"}}],[11,"new","","Allocate `content` on the heap and create a sharable `External` reference to it",6,{"inputs":[{"name":"t"}],"output":{"name":"self"}}],[11,"from_box","","To interface with traditional owned boxes",6,{"inputs":[{"name":"box"}],"output":{"name":"self"}}],[11,"steal","","Like `clone`, just to make the danger more clear",6,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[11,"into_box","","To interface with traditional owned boxes",6,{"inputs":[{"name":"self"}],"output":{"name":"box"}}],[11,"clone","","",6,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[11,"deref","","",6,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[11,"deref_mut","","",6,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[11,"is_still_compact","","",6,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"dynamic_size_bytes","","",6,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"compact","","",6,null],[11,"decompact","","",6,null],[8,"Message","","Trait that a datastructure must implement in order to be sent and received as a message.",null,null],[8,"Actor","","Trait that Actors instance have to implement for a `Swarm` so their internally stored instance ID can be gotten and set.",null,null],[10,"id","","Get the full ID (Actor type id + instance id) of `self`",7,{"inputs":[{"name":"self"}],"output":{"name":"id"}}],[10,"set_id","","Set the full ID (Actor type id + instance id) of `self` (called internally by `Swarm`)",7,{"inputs":[{"name":"self"},{"name":"id"}],"output":null}]],"paths":[[3,"Packet"],[3,"ID"],[3,"Networking"],[4,"Fate"],[3,"ActorSystem"],[3,"World"],[3,"External"],[8,"Actor"]]};
searchIndex["kay_codegen"] = {"doc":"","items":[[3,"Model","kay_codegen","",null,null],[12,"actors","","",0,null],[12,"traits","","",0,null],[3,"ActorDef","","",null,null],[12,"handlers","","",1,null],[12,"impls","","",1,null],[12,"defined_here","","",1,null],[3,"TraitDef","","",null,null],[12,"handlers","","",2,null],[3,"Handler","","",null,null],[4,"HandlerType","","",null,null],[13,"Handler","","",3,null],[13,"Init","","",3,null],[5,"scan_and_generate","","",null,{"inputs":[{"name":"str"}],"output":null}],[5,"generate","","",null,{"inputs":[{"name":"model"}],"output":{"name":"string"}}],[11,"map_handlers","","",1,{"inputs":[{"name":"self"},{"name":"ty"},{"name":"handlerorigin"},{"name":"handlertype"},{"name":"f"}],"output":{"name":"vec"}}],[11,"map_handlers","","",2,{"inputs":[{"name":"self"},{"name":"path"},{"name":"handlertype"},{"name":"f"}],"output":{"name":"vec"}}],[11,"map_handlers","","",0,null],[11,"map_handlers_args","","",0,null],[11,"map_trait_handlers","","",0,null],[11,"map_trait_handlers_args","","",0,null],[11,"generate_setups","","",0,{"inputs":[{"name":"self"}],"output":{"name":"tokens"}}],[11,"generate_trait_ids_and_messages","","",0,{"inputs":[{"name":"self"}],"output":{"name":"tokens"}}],[11,"generate_actor_ids_messages_and_conversions","","",0,{"inputs":[{"name":"self"}],"output":{"name":"tokens"}}],[11,"default","","",0,{"inputs":[],"output":{"name":"model"}}],[11,"default","","",1,{"inputs":[],"output":{"name":"actordef"}}],[11,"default","","",2,{"inputs":[],"output":{"name":"traitdef"}}],[11,"clone","","",4,{"inputs":[{"name":"self"}],"output":{"name":"handler"}}],[11,"clone","","",3,{"inputs":[{"name":"self"}],"output":{"name":"handlertype"}}],[11,"eq","","",3,{"inputs":[{"name":"self"},{"name":"handlertype"}],"output":{"name":"bool"}}]],"paths":[[3,"Model"],[3,"ActorDef"],[3,"TraitDef"],[4,"HandlerType"],[3,"Handler"]]};
initSearch(searchIndex);
